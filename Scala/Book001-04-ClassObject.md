# 第4章 类和对象
>

## 4.1 类、字段和方法
* 定义类
```
class [类名] {
    // 类定义
}
```
* 创建类
```
new [类名]
```
* 类定义中的字段和方法统称为成员
  * 字段定义：var或val
    * 私有字段：private
    * Scala中public是默认的访问级别
  * 方法定义：def
    * 方法的任何参数都是val，不能赋值
    * 方法中的return语句是可以去掉的。如果没有显式的返回语句，Scala方法将返回方法中最后一次计算等到的值。
    * 方法的推荐风格是尽量避免使用返回语句，尤其是多条返回语句。
    * 如果去掉方法体前面的等号，那么方法的结果类型就必定是Unit。这种说法不论方法体里包含什么都成立，因为Scala编译器可以把任何类型转换为Unit。
```
def f() : Unit = "this String gets lost too"
def g() {"this String gets lost too"}
```

## 4.2 分号推断
* Scala中，语句末尾的分号通常是可选的，若一行里仅有一个语句也可以不加。不过，如果一行包含多条语句时，分号则是必加的

* 分号推断的规则
  1. 疑问行由一个不能作为语句结尾的字结束，如句点或中缀操作符。
  2. 下一行开始于不能作为语句开始的词。
  3. 行结束于括号\(\.\.\.\)或方框\[\.\.\.\]内部，因为这些符号不可能容纳多个语句。

## 4.3 Singleton对象
Scala不能定义静态成员，而是以单例对象取代。除了用object关键字替换class关键字以外，单例对象的定义看上去与类定义一致。如下：
```
import scala.collection.mutable.Map
object [类名] {
  // 类定义
}
```

* 当单例对象与某个类共享同一个名称时，它就被称为是这个类的伴生对象（companion object）。类和它的伴生对象必须定义在一个文件里。类被称为是这个单例对象的伴生类（companion class）。类和它的伴生对象可以互相访问其私有成员。

* 单例对象不只是静态方法的工具类。它同样是头等的对象。因此单例对象的名字可以被看作是贴在对象上的名签

* 定义单例对象并没有定义类型（在Scala的抽象层次上说）。如果只有单例对象的定义，就不能建立单例对象类型的变量。或者可以认为，类的类型是由单例对象的伴生类定义的。然而，单例对象扩展了父类并可以混入特质。因此，可以使用类型调用单例对象的方法，或者用类型的实例变量指代单例对象，并把它传递给需要类型参数的方法。

* 类和单例对象间的差别：单例对象不带参数，而类可以。因为单例对象不是用new关键字实例化的，所以没机会传递给它的实例化参数。每个单例对象都被实现为虚构类（synthetic class，虚构类的名字是 \[对象名\] \+ \[美元符号\]）的实例，并指向静态的变量，因此它们与Java静态类有着相同初始化语义。特别要指出的是，单例对象在第一次被访问的时候才会被初始化。

* 不与伴生类共享名称的单例对象被称为独立对象（standalone object）。它可以用在很多地方，例如作为相关功能方法的工具类，或者定义Scala应用的入口点。

## 4.4 Scala程序
想要编写能够独立运行的Scala程序，就必需创建有main方法（仅带一个参数Array\[String\]，且结果类型为Unit的单例对象。任何拥有合适签名的main方法的单例对象都可以用来作为程序的入口点。
```
// 这里对象的名字是Runner。它的main方法具有合适的签名，所以用作程序。
object Runner {
    def main(args: Array[String]) {
        // pass
    }
}
```
**注意**：Scala的每个源文件都隐含了对包java\.lang、包scala，以及单例对象Predef的成员引用。包scala中的Predef对象包含了许多有用的方法。例如，Scala源文件中写下println语句，实际调用的是Predef的println（Predef\.println 转而调用Console\.println，完成真正的工作）。写下assert，实际是在调用Predef\.assert。


## 4.5 Application特质
Scala提供了特质scala\.Application,可以减少一些输入工作。
```
object Runner extends Application {
    // pass
}
```
使用方法是，首先在单例对象名后面写上“extends Application"。然后代之以main方法，你可以把想要执行的代码直接放在单例对象的花括号之间。如此而以。之后可以正常的编译和运行。

能这么做，是因为特质Application声明了带有合适签名的main方法，并被你写的单例对象继承，使它可以像Scala程序那样。花括号之间的代码被收集进了单例对象的主构造器，并在类被初始化时执行。

继承自Application比编写完整的main方法要方便，不过它也有缺点。首先，如果想访问命令行参数的话就不能用它，因为args数组不可访问。第二，因为某些JVM线程模型里的局限，如对于多线程程序需要自行编写main方法；最后，某些JVM的实现没有优化被Application特质执行的对象的初始化代码。因此只有当程序相对简单并且是单线程的情况下才可以继承Application特质。

## 4.6 小结